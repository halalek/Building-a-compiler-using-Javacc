/* Generated By:JavaCC: Do not edit this line. MyNewGrammar.java */
package cmppp;
import java.io.*;
import nodes.*;
import java.util.HashMap;

public class MyNewGrammar implements MyNewGrammarConstants {
  static String s = null;
  static HashMap<String,FunctionDef> functions = new HashMap<String,FunctionDef>();

  public static void main(String args []) throws ParseException,FileNotFoundException
  {
    FileInputStream fis = new FileInputStream("D:/test.txt");
    MyNewGrammar parser = new MyNewGrammar(fis);
//    MyNewGrammar parser = new MyNewGrammar(System.in);
    AbstractTreeNode n = start();
    n.execute(new Context());
   // String code = (String)n.convert(new Context());
   // System.out.println(code);
  }

  static final public BlockNode start() throws ParseException {
  BlockNode n = new BlockNode();
  AbstractTreeNode c;
    label_1:
    while (true) {
      c = stmt();
                n.addChild(c);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IF:
      case FOR:
      case WHILE:
      case DO:
      case SWITCH:
      case INT:
      case BOOL:
      case FLOAT:
      case DOUBLE:
      case STRING:
      case CHAR:
      case FUNC:
      case Id:
      case Cout:
      case Cin:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
    }
    jj_consume_token(0);
  System.out.println("Tree was built successfully!");
    {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

  static final public AbstractTreeNode stmt() throws ParseException {
  AbstractTreeNode n = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IF:
        n = ifStmt();
        break;
      case WHILE:
        n = whileStmt();
        break;
      case DO:
        n = dowhileStmt();
        break;
      case FOR:
        n = forStmt();
        break;
      case Id:
        n = assignStmt();
        break;
      case Cin:
        n = readStmt();
        break;
      case Cout:
        n = writeStmt();
        break;
      case SWITCH:
        n = switchStatement();
        break;
      case FUNC:
        FuncDef();
        break;
      case INT:
      case BOOL:
      case FLOAT:
      case DOUBLE:
      case STRING:
      case CHAR:
        n = defAssign();
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
  System.out.println(e);
  Token t;
  do
  {
    t = getNextToken();
  }
  while(t.kind != Semicolon);
    }
  if (n == null)
        n = new BlockNode();
  {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

  static final public ExpressionNode E() throws ParseException {
  Token t = null;
  ExpressionNode n1, n2 = null;
  System.out.println("E()");
    n1 = F();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
    case MINUS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        t = jj_consume_token(PLUS);
        break;
      case MINUS:
        t = jj_consume_token(MINUS);
        break;
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n2 = E();
      break;
    default:
      jj_la1[3] = jj_gen;
      ;
    }
    if (t == null)
        {if (true) return n1;}
    else
    {

        ExpressionNode en = new ExpressionNode();
        en.addChild(n1);
        en.addChild(n2);
        en.setOperator(t.image);
        {if (true) return en;}
    }
    throw new Error("Missing return statement in function");
  }

  static final public ExpressionNode F() throws ParseException {
  Token t = null;
  ExpressionNode n1,n2 = null;
    n1 = N();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MULTIPLY:
    case DIVIDE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTIPLY:
        t = jj_consume_token(MULTIPLY);
        break;
      case DIVIDE:
        t = jj_consume_token(DIVIDE);
        break;
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n2 = F();
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
    if (t == null)
        {if (true) return n1;}
    else
    {
        ExpressionNode en = new ExpressionNode();
        en.addChild(n1);
        en.addChild(n2);
        en.setOperator(t.image);
        {if (true) return en;}
    }
    throw new Error("Missing return statement in function");
  }

  static final public ExpressionNode N() throws ParseException {
  Token t1 = null, t2 = null,t=null;
  ExpressionNode n = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMBER:
      t1 = jj_consume_token(NUMBER);
      break;
    case NUMBERINT:
      t1 = jj_consume_token(NUMBERINT);
      break;
    case LeftParenthesis:
      jj_consume_token(LeftParenthesis);
      n = E();
      jj_consume_token(RightParenthesis);
      break;
    case Id:
      t2 = jj_consume_token(Id);
      break;
    case STRINGValue:
      t1 = jj_consume_token(STRINGValue);
      break;
    case TRUE:
      t1 = jj_consume_token(TRUE);
      break;
    case FALSE:
      t1 = jj_consume_token(FALSE);
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    //System.out.println(s);
    if (t1 != null)
    {
      ConstantNode cn = new ConstantNode();
      // System.out.println(cn.getdefType());
      if (s != null)
      {
        System.out.println(s);
        if (s.equals("int"))
        {
          try
          {
            System.out.println("cast to int");
            cn.setValue(Integer.parseInt(t1.image));
          }
          catch (NumberFormatException e)
          {
            System.out.println("this is not int");
          }
          s = null;
        }
        else if (s.equals("float"))
        {
          try
          {
            System.out.println("cast to float");
            cn.setValue(Float.parseFloat(t1.image));
          }
          catch (NumberFormatException e)
          {
            System.out.println("this is not float");
          }
          s = null;
        }
        else if (s.equals("string"))
        {
//          System.out.println("cast to string");
//          String ss;
//          ss = t1.image;
//         // String ww = ss.substring(0, ss.length());
//          System.out.println(ss);
//          cn.setValue(ss);

          if(t1.image.startsWith("'"))
            {System.out.println("cast to string");
            cn.setValue(t1.image);}
            else {

             System.out.println("this is not string");
            }

          s = null;
        }

        else if (s.equals("bool"))
        {

                  if(t1.image.equals("true") || t1.image.equals("false") )
                    {System.out.println("cast to bool");
                    cn.setValue(t1.image);}
                    else
                    {
                     System.out.println("this is not bool");
                    }


                  s = null;
        }
        else if (s.equals("double"))
        {
          try
          {
            cn.setValue(Double.parseDouble(t1.image));
          }
          catch (NumberFormatException e)
          {
            System.out.println("this is not double");
          }
          s = null;
        }
        else if (s.equals("char"))
        {
          String ss1 = t1.image;
         // String ww = ss1.substring(1, ss1.length());
          char ss;
          if (ss1.length() == 3&&t1.image.startsWith("'"))
          {
            ss = ss1.charAt(0);
            System.out.println(ss);
            cn.setValue(ss);
            s = null;
          }
          else
          {
            System.out.println("this is not char");
          }
          s = null;
        }
      }
      else if (s == null)
      {

//     System.out.println("  undefined "+"you must define it");
        if ((t1.image).contains("."))
        {
          // cn.setType("double");
          cn.setValue(Double.parseDouble(t1.image));
        }
        else if (t1.image.startsWith("'"))
        {
          String ss;
          ss = t1.image;
          String ww = ss.substring(1, ss.length());
          System.out.println(ww);
          //cn.setType("string");
          cn.setValue(ww);
        }
         else if (t1.image.equals("true"))
                {
                  //cn.setType("int");
                  System.out.println("true");
                  cn.setValue(t1.image);
                }

                 else if (t1.image.equals("false"))
                        {
                          //cn.setType("int");
                          System.out.println("false");
                          cn.setValue(t1.image);
                        }
        else if (!t1.image.contains("."))
        {
          //cn.setType("int");
          System.out.println("int");
          cn.setValue(Integer.parseInt(t1.image));
        }
      }
      {if (true) return cn;}
    }
    else if (n != null)
    {if (true) return n;}
    else
    {
      System.out.println("variable");
      // System.out.println(t2.image);
      VariableNode vn = new VariableNode();
      vn.setName(t2.image);
      {if (true) return vn;}
    }
    throw new Error("Missing return statement in function");
  }

  static final public IfNode ifStmt() throws ParseException {
  IfNode res = new IfNode();
  AbstractTreeNode n, nn;
  AbstractTreeNode n1=null,nn1;
  BlockNode cn = new BlockNode();
   BlockNode cn1 = new BlockNode();
    BlockNode cn2 = new BlockNode();
  BlockNode en = null;
   BlockNode en1 = null;
   Token t1=null,t2=null;
    jj_consume_token(IF);
    jj_consume_token(LeftParenthesis);
    n = condition();
    jj_consume_token(RightParenthesis);
    jj_consume_token(LeftBrace);
    label_2:
    while (true) {
      nn = stmt();
      cn.addChild(nn);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IF:
      case FOR:
      case WHILE:
      case DO:
      case SWITCH:
      case INT:
      case BOOL:
      case FLOAT:
      case DOUBLE:
      case STRING:
      case CHAR:
      case FUNC:
      case Id:
      case Cout:
      case Cin:
        ;
        break;
      default:
        jj_la1[7] = jj_gen;
        break label_2;
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BREAK:
      t1 = jj_consume_token(BREAK);
      jj_consume_token(Semicolon);
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IF:
        case FOR:
        case WHILE:
        case DO:
        case SWITCH:
        case INT:
        case BOOL:
        case FLOAT:
        case DOUBLE:
        case STRING:
        case CHAR:
        case FUNC:
        case Id:
        case Cout:
        case Cin:
          ;
          break;
        default:
          jj_la1[8] = jj_gen;
          break label_3;
        }
        nn = stmt();
                  cn1.addChild(nn);
      }
      break;
    default:
      jj_la1[9] = jj_gen;
      ;
    }
      if(t1!=null)
      {res.breakk=false;
      System.out.println("breaaaaaaaaaaaaak");
      }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONTINUE:
      t2 = jj_consume_token(CONTINUE);
      jj_consume_token(Semicolon);
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IF:
        case FOR:
        case WHILE:
        case DO:
        case SWITCH:
        case INT:
        case BOOL:
        case FLOAT:
        case DOUBLE:
        case STRING:
        case CHAR:
        case FUNC:
        case Id:
        case Cout:
        case Cin:
          ;
          break;
        default:
          jj_la1[10] = jj_gen;
          break label_4;
        }
        nn = stmt();
                            cn1.addChild(nn);
      }
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
            if(t2!=null)
            {
            System.out.println("cooooooooooooooooooo");
            }
    jj_consume_token(RightBrace);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IFELSE:
      jj_consume_token(IFELSE);
      jj_consume_token(LeftParenthesis);
                                 en1 = new BlockNode();
      n1 = condition();
      jj_consume_token(RightParenthesis);
      jj_consume_token(LeftBrace);
      label_5:
      while (true) {
        nn1 = stmt();
        en1.addChild(nn1);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IF:
        case FOR:
        case WHILE:
        case DO:
        case SWITCH:
        case INT:
        case BOOL:
        case FLOAT:
        case DOUBLE:
        case STRING:
        case CHAR:
        case FUNC:
        case Id:
        case Cout:
        case Cin:
          ;
          break;
        default:
          jj_la1[12] = jj_gen;
          break label_5;
        }
      }
      jj_consume_token(RightBrace);
      break;
    default:
      jj_la1[13] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELSE:
      jj_consume_token(ELSE);
      jj_consume_token(LeftBrace);
                           en = new BlockNode();
      label_6:
      while (true) {
        nn = stmt();
                                                                  en.addChild(nn);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IF:
        case FOR:
        case WHILE:
        case DO:
        case SWITCH:
        case INT:
        case BOOL:
        case FLOAT:
        case DOUBLE:
        case STRING:
        case CHAR:
        case FUNC:
        case Id:
        case Cout:
        case Cin:
          ;
          break;
        default:
          jj_la1[14] = jj_gen;
          break label_6;
        }
      }
      jj_consume_token(RightBrace);
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
    res.addChild(n);
    res.addChild(cn);
     if (en1 != null)
      {res.addChild(n1);
      res.addChild(en1);}
       if (en != null)
                res.addChild(en);

        if(t1!=null)
          res.addChild(cn1);

         if(t2!=null)
          res.addChild(cn2);
    {if (true) return res;}
    throw new Error("Missing return statement in function");
  }

  static final public WhileNode whileStmt() throws ParseException {
  WhileNode wnode = new WhileNode();
  BlockNode bnode = new BlockNode();
  BlockNode bnode1 = new BlockNode();
   BlockNode bnode2 = new BlockNode();
  AbstractTreeNode n,s;
  Token t1=null,t2=null;
  System.out.println("while");
    jj_consume_token(WHILE);
    jj_consume_token(LeftParenthesis);
    n = condition();
    jj_consume_token(RightParenthesis);
    jj_consume_token(LeftBrace);
    label_7:
    while (true) {
      s = stmt();
                 bnode.addChild(s);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IF:
      case FOR:
      case WHILE:
      case DO:
      case SWITCH:
      case INT:
      case BOOL:
      case FLOAT:
      case DOUBLE:
      case STRING:
      case CHAR:
      case FUNC:
      case Id:
      case Cout:
      case Cin:
        ;
        break;
      default:
        jj_la1[16] = jj_gen;
        break label_7;
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BREAK:
      t1 = jj_consume_token(BREAK);
      jj_consume_token(Semicolon);
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IF:
        case FOR:
        case WHILE:
        case DO:
        case SWITCH:
        case INT:
        case BOOL:
        case FLOAT:
        case DOUBLE:
        case STRING:
        case CHAR:
        case FUNC:
        case Id:
        case Cout:
        case Cin:
          ;
          break;
        default:
          jj_la1[17] = jj_gen;
          break label_8;
        }
        s = stmt();
                   bnode1.addChild(s);
      }
      break;
    default:
      jj_la1[18] = jj_gen;
      ;
    }
      if(t1!=null)
      {wnode.f=false;
      System.out.println("breaaaaaaaaaaaaak");
      }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONTINUE:
      t2 = jj_consume_token(CONTINUE);
      jj_consume_token(Semicolon);
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IF:
        case FOR:
        case WHILE:
        case DO:
        case SWITCH:
        case INT:
        case BOOL:
        case FLOAT:
        case DOUBLE:
        case STRING:
        case CHAR:
        case FUNC:
        case Id:
        case Cout:
        case Cin:
          ;
          break;
        default:
          jj_la1[19] = jj_gen;
          break label_9;
        }
        s = stmt();
                         bnode2.addChild(s);
      }
      break;
    default:
      jj_la1[20] = jj_gen;
      ;
    }
            if(t2!=null)
            {wnode.continu=false;
            System.out.println("cooooooooooooooooooo");
            }
    jj_consume_token(RightBrace);
    wnode.addChild(n);
    wnode.addChild(bnode);
    if(t1!=null)
    {
     wnode.addChild(bnode1);
    }

    if(t2!=null)
        {
         wnode.addChild(bnode2);
        }
    {if (true) return wnode;}
    throw new Error("Missing return statement in function");
  }

  static final public DoWhileNode dowhileStmt() throws ParseException {
  DoWhileNode wnode = new DoWhileNode();
  BlockNode bnode = new BlockNode();
  BlockNode bnode1 = new BlockNode();
   BlockNode bnode2 = new BlockNode();
  AbstractTreeNode n,s;
  Token t1=null,t2=null;
  System.out.println("Do while");
    jj_consume_token(DO);
    jj_consume_token(LeftBrace);
    label_10:
    while (true) {
      s = stmt();
                 bnode.addChild(s);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IF:
      case FOR:
      case WHILE:
      case DO:
      case SWITCH:
      case INT:
      case BOOL:
      case FLOAT:
      case DOUBLE:
      case STRING:
      case CHAR:
      case FUNC:
      case Id:
      case Cout:
      case Cin:
        ;
        break;
      default:
        jj_la1[21] = jj_gen;
        break label_10;
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BREAK:
      t1 = jj_consume_token(BREAK);
      jj_consume_token(Semicolon);
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IF:
        case FOR:
        case WHILE:
        case DO:
        case SWITCH:
        case INT:
        case BOOL:
        case FLOAT:
        case DOUBLE:
        case STRING:
        case CHAR:
        case FUNC:
        case Id:
        case Cout:
        case Cin:
          ;
          break;
        default:
          jj_la1[22] = jj_gen;
          break label_11;
        }
        s = stmt();
                     bnode1.addChild(s);
      }
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
      if(t1!=null)
      {wnode.f=false;
      System.out.println("breaaaaaaaaaaaaak");
      }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONTINUE:
      t2 = jj_consume_token(CONTINUE);
      jj_consume_token(Semicolon);
      label_12:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IF:
        case FOR:
        case WHILE:
        case DO:
        case SWITCH:
        case INT:
        case BOOL:
        case FLOAT:
        case DOUBLE:
        case STRING:
        case CHAR:
        case FUNC:
        case Id:
        case Cout:
        case Cin:
          ;
          break;
        default:
          jj_la1[24] = jj_gen;
          break label_12;
        }
        s = stmt();
                         bnode2.addChild(s);
      }
      break;
    default:
      jj_la1[25] = jj_gen;
      ;
    }
            if(t2!=null)
            {wnode.continu=false;
            System.out.println("cooooooooooooooooooo");
            }
    jj_consume_token(RightBrace);
    jj_consume_token(WHILE);
    jj_consume_token(LeftParenthesis);
    n = condition();
    jj_consume_token(RightParenthesis);
    jj_consume_token(Semicolon);
    wnode.addChild(n);
    wnode.addChild(bnode);
     if(t1!=null)
        {
         wnode.addChild(bnode1);
        }
    if(t2!=null)
        {
         wnode.addChild(bnode2);
        }
    {if (true) return wnode;}
    throw new Error("Missing return statement in function");
  }

  static final public FoorNode forStmt() throws ParseException {
  FoorNode wnode = new FoorNode();
  BlockNode bnode = new BlockNode();
   BlockNode bnode1 = new BlockNode();
   BlockNode bnode2 = new BlockNode();
  AbstractTreeNode n=null,n1=null,n2=null,s;
  Token t,t1=null,t2=null;
  System.out.println("for");
    jj_consume_token(FOR);
    jj_consume_token(LeftParenthesis);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Id:
      n1 = assignStmt();
      break;
    case Semicolon:
      jj_consume_token(Semicolon);
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMBER:
    case NUMBERINT:
    case LeftParenthesis:
    case NOT:
    case TRUE:
    case FALSE:
    case STRINGValue:
    case Id:
      n = condition();
      break;
    default:
      jj_la1[27] = jj_gen;
      ;
    }
    jj_consume_token(Semicolon);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Id:
      n2 = assignStmt();
      break;
    default:
      jj_la1[28] = jj_gen;
      ;
    }
    jj_consume_token(RightParenthesis);
    jj_consume_token(LeftBrace);
    label_13:
    while (true) {
      s = stmt();
                 bnode.addChild(s);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IF:
      case FOR:
      case WHILE:
      case DO:
      case SWITCH:
      case INT:
      case BOOL:
      case FLOAT:
      case DOUBLE:
      case STRING:
      case CHAR:
      case FUNC:
      case Id:
      case Cout:
      case Cin:
        ;
        break;
      default:
        jj_la1[29] = jj_gen;
        break label_13;
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BREAK:
      t1 = jj_consume_token(BREAK);
      jj_consume_token(Semicolon);
      label_14:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IF:
        case FOR:
        case WHILE:
        case DO:
        case SWITCH:
        case INT:
        case BOOL:
        case FLOAT:
        case DOUBLE:
        case STRING:
        case CHAR:
        case FUNC:
        case Id:
        case Cout:
        case Cin:
          ;
          break;
        default:
          jj_la1[30] = jj_gen;
          break label_14;
        }
        s = stmt();
                       bnode1.addChild(s);
      }
      break;
    default:
      jj_la1[31] = jj_gen;
      ;
    }
        if(t1!=null)
        {wnode.f=false;
        System.out.println("breaaaaaaaaaaaaak");
        }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONTINUE:
      t2 = jj_consume_token(CONTINUE);
      jj_consume_token(Semicolon);
      label_15:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IF:
        case FOR:
        case WHILE:
        case DO:
        case SWITCH:
        case INT:
        case BOOL:
        case FLOAT:
        case DOUBLE:
        case STRING:
        case CHAR:
        case FUNC:
        case Id:
        case Cout:
        case Cin:
          ;
          break;
        default:
          jj_la1[32] = jj_gen;
          break label_15;
        }
        s = stmt();
                         bnode2.addChild(s);
      }
      break;
    default:
      jj_la1[33] = jj_gen;
      ;
    }
            if(t2!=null)
            {
            System.out.println("cooooooooooooooooooo");
            }
    jj_consume_token(RightBrace);
  if(n1!=null){
  wnode.addChild(n1);
  }
    else if(n1==null)//assign
    {
    System.out.println("000000000000000000000000000000000000");
    wnode.selgetbool1(true);
    n1=new FoorNode();
    wnode.addChild(n1);
    }
//wnode.addChild(n1);
if(n==null)//condation
{
System.out.println("7777777777777777777777777");
n=new ConditionNode();
wnode.selcondation(true);
}
    wnode.addChild(n);
    if(n2!=null)//increment
    {bnode.addChild(n2);}
    wnode.addChild(bnode);
    if(t1!=null)
    {wnode.addChild(bnode1);}
//    wnode.setincrement(t.image);
      if(t2!=null)
        {  wnode.addChild(bnode2);}
    {if (true) return wnode;}
    throw new Error("Missing return statement in function");
  }

//ForNode forStmt():
//{
//  ForNode res = new ForNode();
//  Token t,t1=null,t2=null;
//  AbstractTreeNode n1,n2, n4 = null, tmp;
//  BlockNode n3 = new BlockNode();
//}
//{
//	< FOR > <LeftParenthesis >t = <Id >"=" n1 = E()< Semicolon>   n2 = E()< Semicolon>( n4 = E() (t1="--"| t1="++") )?
//	< RightParenthesis >< LeftBrace>
//	(
//	  tmp = stmt() { n3.addChild(tmp); }
//	)+
//	 < RightBrace>
//	{
//	  res.addChild(n1);
//	  res.addChild(n2);
//	  res.addChild(n3);
//	  res.setVarName(t.image);
//	  res.setincrement(t1.image);
//	  if (n4 != null)
//	  	res.addChild(n4);
//	  return res;
//	}
//}
  static final public DefAssignNode defAssign() throws ParseException {
  Token t, t1 = null;
  DefAssignNode anode = new DefAssignNode();
  AbstractTreeNode n=null;
  System.out.println("Define");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT:
      t1 = jj_consume_token(INT);
      break;
    case FLOAT:
      t1 = jj_consume_token(FLOAT);
      break;
    case CHAR:
      t1 = jj_consume_token(CHAR);
      break;
    case STRING:
      t1 = jj_consume_token(STRING);
      break;
    case DOUBLE:
      t1 = jj_consume_token(DOUBLE);
      break;
    case BOOL:
      t1 = jj_consume_token(BOOL);
      break;
    default:
      jj_la1[34] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    t = jj_consume_token(Id);
    jj_consume_token(Semicolon);
    s = t1.image;
    anode.setVarName(t.image);

  //  anode.definecheck(new Context(),t.image);


{if (true) return anode;}
    throw new Error("Missing return statement in function");
  }

  static final public AssignNode assignStmt() throws ParseException {
  Token t,t1=null;
  AssignNode anode = new AssignNode();
  AbstractTreeNode n;
  System.out.println("AssignNode");
    //  (
    //    t1 = < INT >
    //  | t1 = < FLOAT >
    //  | t1 = < CHAR >
    //  | t1 = < STRING >
    //  | t1 = < DOUBLE >
    //  )
            t = jj_consume_token(Id);
    jj_consume_token(Assignment);
    n = E();
    jj_consume_token(Semicolon);
         System.out.println("N()");
          anode.setVarName(t.image);
          anode.addChild(n);
          {if (true) return anode;}
    throw new Error("Missing return statement in function");
  }

  static final public ReadNode readStmt() throws ParseException {
  ReadNode n = new ReadNode();
  AbstractTreeNode n2;
  Token t;
    jj_consume_token(Cin);
    t = jj_consume_token(Id);
    jj_consume_token(Semicolon);
//	System.out.println("please cin ");
//    Scanner s = new Scanner(System.in);
//    System.out.println(varName +"="+ s.nextDouble());
//    n2=s.nextDouble();
//	n.setVarName(t.image);
//	 n.addChild(n2);
//	  return n;

        n.setVarName(t.image);
          {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

  static final public WriteNode writeStmt() throws ParseException {
  WriteNode n = new WriteNode();
  AbstractTreeNode nn;
    jj_consume_token(Cout);
    nn = N();
    jj_consume_token(Semicolon);
          n.addChild(nn);
          {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

  static final public ConditionNode condition() throws ParseException {
  ConditionNode n = new ConditionNode();
  AbstractTreeNode n1,n2,n3,n4,n5=null,n6=null;
  Token t=null,t1;
  Token boole,boole1=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      boole = jj_consume_token(NOT);
                  n.addboole(boole.image);
      break;
    default:
      jj_la1[35] = jj_gen;
      ;
    }
    n1 = E();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Compare:
      t = jj_consume_token(Compare);
      break;
    case AND:
      t = jj_consume_token(AND);
      break;
    case OR:
      t = jj_consume_token(OR);
      break;
    case NOT:
      t = jj_consume_token(NOT);
      break;
    default:
      jj_la1[36] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    n2 = E();
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NOT:
      case AND:
      case OR:
        ;
        break;
      default:
        jj_la1[37] = jj_gen;
        break label_16;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        boole = jj_consume_token(AND);
        break;
      case OR:
        boole = jj_consume_token(OR);
        break;
      case NOT:
        boole = jj_consume_token(NOT);
        break;
      default:
        jj_la1[38] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n3 = E();
      t1 = jj_consume_token(Compare);
      n4 = E();
          n.addboole(boole.image);//center
          n.addChild(n3);
          n.addChild(n4);
          n.addop(t1.image);
    }
          n.addChild(n1);
          n.addChild(n2);
          if(t!=null)
          n.addop(t.image);

          {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

  static final public SwitchNode switchStatement() throws ParseException {
  SwitchNode n = new SwitchNode();
   AbstractTreeNode n1,n2,s;
    BlockNode bnode = new BlockNode();
   Token t,t1,t2=null,t3=null;
    jj_consume_token(SWITCH);
    jj_consume_token(LeftParenthesis);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMBER:
      t = jj_consume_token(NUMBER);
      break;
    case NUMBERINT:
      t = jj_consume_token(NUMBERINT);
      break;
    case STRINGValue:
      t = jj_consume_token(STRINGValue);
      break;
    default:
      jj_la1[39] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(RightParenthesis);
    jj_consume_token(LeftBrace);
    label_17:
    while (true) {
      jj_consume_token(CASE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUMBER:
        t1 = jj_consume_token(NUMBER);
        break;
      case NUMBERINT:
        t1 = jj_consume_token(NUMBERINT);
        break;
      case STRINGValue:
        t1 = jj_consume_token(STRINGValue);
        break;
      default:
        jj_la1[40] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(50);
      label_18:
      while (true) {
        //n.basicvalue=t.image;
         //n.valueofcase(t1.image);
         s = stmt();
              bnode.addChild(s);
  n.basicvalue=t.image;
  n.valueofcase(t1.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IF:
        case FOR:
        case WHILE:
        case DO:
        case SWITCH:
        case INT:
        case BOOL:
        case FLOAT:
        case DOUBLE:
        case STRING:
        case CHAR:
        case FUNC:
        case Id:
        case Cout:
        case Cin:
          ;
          break;
        default:
          jj_la1[41] = jj_gen;
          break label_18;
        }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BREAK:
        t2 = jj_consume_token(BREAK);
        jj_consume_token(Semicolon);
        break;
      default:
        jj_la1[42] = jj_gen;
        ;
      }
 if(t2==null)
 {n.valueofbreak("");}
 if(t2!=null)
 {n.valueofbreak(t2.image);}
 t2=null;
  n.addChild(s);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CASE:
        ;
        break;
      default:
        jj_la1[43] = jj_gen;
        break label_17;
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DEFULT:
      jj_consume_token(DEFULT);
      jj_consume_token(50);
      label_19:
      while (true) {
        s = stmt();
              bnode.addChild(s);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IF:
        case FOR:
        case WHILE:
        case DO:
        case SWITCH:
        case INT:
        case BOOL:
        case FLOAT:
        case DOUBLE:
        case STRING:
        case CHAR:
        case FUNC:
        case Id:
        case Cout:
        case Cin:
          ;
          break;
        default:
          jj_la1[44] = jj_gen;
          break label_19;
        }
      }
 n.addChild(s);
      break;
    default:
      jj_la1[45] = jj_gen;
      ;
    }
    jj_consume_token(RightBrace);
   // n.addChild(s);
    {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

//void switchStatement():
//{Token t;
//}
//{
//  < SWITCH > < LeftParenthesis > t=< Id >< RightParenthesis >
//  < LeftBrace >
//(< CASE > (<NUMBER > | < NUMBERINT >|< Id >|< STRINGValue >) ":" (allStatment())*  (<BREAK> < Semicolon >)?)+
//
//(< DEFULT> ":" (allStatment())+  (<BREAK> < Semicolon >)?)?
//< RightBrace >
//
// { System.out.println("switch"); }
//
//}


//scopenode scope():
//{
//  scopenode n1 = new scopenode();
//  AbstractTreeNode n=null ;
//}
//{
//   <LeftParenthesis >(
//    n = stmt() {n1.addChild(n); }
//  )+ < RightParenthesis >
//  {
//    return n1;
//  }
//}

//
  static final public void FuncDef() throws ParseException {
  FunctionDef fd = new FunctionDef();
  Token name,t = null;
  BlockNode n = new BlockNode();
  AbstractTreeNode an;
  HashMap<String,FunctionDef> old=functions;
  {

  }
  functions=new  HashMap<String,FunctionDef>();
    jj_consume_token(FUNC);
    name = jj_consume_token(Id);
    jj_consume_token(LeftParenthesis);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Id:
      t = jj_consume_token(Id);
                                         fd.getParams().add(t.image);
      label_20:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 51:
          ;
          break;
        default:
          jj_la1[46] = jj_gen;
          break label_20;
        }
        jj_consume_token(51);
        t = jj_consume_token(Id);
                         fd.getParams().add(t.image);
      }
      break;
    default:
      jj_la1[47] = jj_gen;
      ;
    }
    jj_consume_token(RightParenthesis);
    jj_consume_token(LeftBrace);
    label_21:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IF:
      case FOR:
      case WHILE:
      case DO:
      case SWITCH:
      case INT:
      case BOOL:
      case FLOAT:
      case DOUBLE:
      case STRING:
      case CHAR:
      case FUNC:
      case Id:
      case Cout:
      case Cin:
        ;
        break;
      default:
        jj_la1[48] = jj_gen;
        break label_21;
      }
      an = stmt();
                  n.addChild(an);
    }
    jj_consume_token(RightBrace);
          fd.setName(name.image);
          fd.setRoot(n);
          fd.getfunctionin().push(functions);
          {

          }
          functions= old;
          functions.put(fd.getName(),fd);
  }

  static final public FuncCallNode FuncCall() throws ParseException {
  FuncCallNode node = new FuncCallNode();
  Token t;
  AbstractTreeNode n;
    t = jj_consume_token(Id);
    jj_consume_token(LeftParenthesis);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMBER:
    case NUMBERINT:
    case LeftParenthesis:
    case TRUE:
    case FALSE:
    case STRINGValue:
    case Id:
      n = E();
                                         node.addChild(n);
      label_22:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 51:
          ;
          break;
        default:
          jj_la1[49] = jj_gen;
          break label_22;
        }
        jj_consume_token(51);
        n = E();
                node.addChild(n);
      }
      break;
    default:
      jj_la1[50] = jj_gen;
      ;
    }
    jj_consume_token(RightParenthesis);
    jj_consume_token(Semicolon);
    node.setFunctionName(t.image);
    node.setFunctions(functions);
    {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public MyNewGrammarTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[51];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x3f0f2000,0x3f0f2000,0x60,0x60,0x180,0x180,0x40000600,0x3f0f2000,0x3f0f2000,0x100000,0x3f0f2000,0x200000,0x3f0f2000,0x8000,0x3f0f2000,0x4000,0x3f0f2000,0x3f0f2000,0x100000,0x3f0f2000,0x200000,0x3f0f2000,0x3f0f2000,0x100000,0x3f0f2000,0x200000,0x1000,0x40000600,0x0,0x3f0f2000,0x3f0f2000,0x100000,0x3f0f2000,0x200000,0x3f000000,0x0,0x0,0x0,0x0,0x600,0x600,0x3f0f2000,0x100000,0x400000,0x3f0f2000,0x800000,0x0,0x0,0x3f0f2000,0x0,0x40000600,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x1d000,0x1d000,0x0,0x0,0x0,0x0,0x6c00,0x1d000,0x1d000,0x0,0x1d000,0x0,0x1d000,0x0,0x1d000,0x0,0x1d000,0x1d000,0x0,0x1d000,0x0,0x1d000,0x1d000,0x0,0x1d000,0x0,0x4000,0x6c20,0x4000,0x1d000,0x1d000,0x0,0x1d000,0x0,0x0,0x20,0xe8,0xe0,0xe0,0x2000,0x2000,0x1d000,0x0,0x0,0x1d000,0x0,0x80000,0x4000,0x1d000,0x80000,0x6c00,};
   }

  /** Constructor with InputStream. */
  public MyNewGrammar(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public MyNewGrammar(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new MyNewGrammarTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 51; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 51; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public MyNewGrammar(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new MyNewGrammarTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 51; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 51; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public MyNewGrammar(MyNewGrammarTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 51; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(MyNewGrammarTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 51; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List jj_expentries = new java.util.ArrayList();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[52];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 51; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 52; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

}
